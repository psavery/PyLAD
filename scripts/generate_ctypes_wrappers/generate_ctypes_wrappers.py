import copy
from pathlib import Path
import subprocess

from pylad.utils import xisl_paths

# First, run ctypesgen on the library.
# The paths for these are set by environment variables.
header_path = xisl_paths.path_to_xisl_header()
library_path = xisl_paths.path_to_xisl_library()
ctypesgen_file = 'xisl_ctypesgen.py'
output_file = 'xisl_ctypes.py'

cmd = [
    'ctypesgen',
    str(header_path),
    '-l',
    str(library_path),
    '-o',
    str(ctypesgen_file),
    '--no-embed-preamble',
]

subprocess.run(cmd)

# Remove these files that we will not use

# Now, try to extract only what we need and write it out to
# a separate file.
libname = 'lib'

file_preamble = """
# This file was auto-generated by generate_ctypes_wrappers.py
# It is an attempt to define signatures automatically on all XISL functions.
# The signatures are only really needed as a safety feature (type checking
# will be performed when we call them via ctypes). As long as we are certain
# that the types match, we are actually able to skip using this script.
"""

# Add the ctypes premable
file_preamble += Path('ctypes_preamble.py').read_text()

file_preamble += """
# Import ctypes types manually (update if needed)
from ctypes import (
    CFUNCTYPE, c_char, c_double, c_int, c_long, c_size_t, c_ubyte, c_uint,
    c_ulong, c_ushort, Structure
)

def add_xisl_ctypes(lib):
    # Define a few types manually (update if needed)
    BOOL = c_int
    WORD = c_ushort
    DWORD = c_uint
    CHAR = c_char
    BYTE = c_ubyte
    HANDLE = POINTER(None)
    HWND = HANDLE
    UINT = c_uint
    ACQDESCPOS = POINTER(None)
    HACQDESC = HANDLE
    DEX_RETURN = c_uint
"""

# These are no longer needed
Path('ctypes_preamble.py').unlink()
Path('ctypes_loader.py').unlink()

with open(output_file, 'w') as wf:
    wf.write(file_preamble)
    indent = ' ' * 4
    with open(ctypesgen_file, 'r') as rf:
        for line in rf:
            if '.argtypes =' in line:
                # Write out the next two lines
                wf.write('\n')
                wf.write(f'{indent}{libname}.{line.strip()}\n')
                line = next(rf)
                wf.write(f'{indent}{libname}.{line.strip()}\n')


def extract_undefined_names(output: str) -> list[str]:
    ret = []
    identifier = 'undefined name'
    for line in output.split('\n'):
        if identifier in line:
            name = line.split(identifier)[1].strip()[1:-1]
            if name not in ret:
                ret.append(name)

    return ret


with open(output_file, 'r') as rf:
    original_output_text = rf.read()


def read_list(line, rf) -> str:
    # Keep on writing until we hit the other end
    output_text = line
    while line.strip() != ']':
        line = next(rf)
        line = line.split('#')[0]
        output_text += line
    output_text += '\n'
    return output_text


# Here is how we are going to extract the identifiers we still need:
# We are going to run flake8 on the script and extract all missing
# identifiers. We will then locate these identifiers in the ctypesgen_file,
# and add them to our script *in the order that they occur
# within the ctypesgen_file* (the order is important because
# some identifiers must be defined before other ones).
# We will then check if any identifiers are missing (some identifiers are
# defined using other identifiers), and then we will repeat again, recursively.
# We will have a master list of missing identifiers, and each time we
# create our script, we will start over from the original script, since the
# order is important.
missing = []
while True:
    # Now recursively run flake8 on the output, and add any missing
    # names, until we finish
    out = subprocess.run(['flake8', output_file], capture_output=True)

    new_missing = extract_undefined_names(out.stdout.decode())
    if not new_missing:
        # We are done!
        break

    # Concatenate the new missing names to the already missing names.
    for name in new_missing:
        if name not in missing:
            missing.append(name)

    print('Looking for missing names:', missing)
    output_text = copy.deepcopy(original_output_text)
    with open(output_file, 'a') as wf:
        output_text += '\n'
        # Find where these are defined in the file
        with open(ctypesgen_file, 'r') as rf:
            for line in rf:
                for name in list(missing):
                    if f'{name} =' in line:
                        # Write this line to our file
                        # Remove anything to the right of a comment
                        line = line.split('#')[0]

                        output_text += f'\n{line}'
                        if line.endswith('['):
                            output_text += read_list(line, rf)
                    elif f'class {name}(' in line:
                        output_text += f'\n{line}'
                        line = next(rf)

                        # Keep on reading until slots and fields have been read
                        fields_read = False
                        while not fields_read:
                            if line.strip().endswith('['):
                                output_text += read_list(line, rf)
                            else:
                                output_text += line
                            fields_read = '_fields_' in line
                            line = next(rf)

                with open(output_file, 'w') as wf:
                    wf.write(output_text)

# Run black on the file to format it
subprocess.run(['black', output_file])

# Remove the ctypesgen_file (no longer needed)
# Path(ctypesgen_file).unlink()
